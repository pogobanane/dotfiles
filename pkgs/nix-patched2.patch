tryEval: catch all EvalError exceptionsFrom 7b9fb7d29ebcbca7a7be52ff42cdddb039f57eed Mon Sep 17 00:00:00 2001
From: Pogobanane <aenderboy@gmx.de>
Date: Mon, 3 Jul 2023 18:13:19 +0200
Subject: [PATCH] tryEval: catch all EvalError exceptions

---
 src/libexpr/primops.cc | 7 ++-----
 1 file changed, 2 insertions(+), 5 deletions(-)

diff --git a/src/libexpr/primops.cc b/src/libexpr/primops.cc
index 5dfad470a..af1a12c31 100644
--- a/src/libexpr/primops.cc
+++ b/src/libexpr/primops.cc
@@ -875,7 +875,7 @@ static void prim_tryEval(EvalState & state, const PosIdx pos, Value * * args, Va
         state.forceValue(*args[0], pos);
         attrs.insert(state.sValue, args[0]);
         attrs.alloc("success").mkBool(true);
-    } catch (AssertionError & e) {
+    } catch (BaseError & e) {
         attrs.alloc(state.sValue).mkBool(false);
         attrs.alloc("success").mkBool(false);
     }
@@ -894,10 +894,7 @@ static RegisterPrimOp primop_tryEval({
       Try to shallowly evaluate *e*. Return a set containing the
       attributes `success` (`true` if *e* evaluated successfully,
       `false` if an error was thrown) and `value`, equalling *e* if
-      successful and `false` otherwise. `tryEval` will only prevent
-      errors created by `throw` or `assert` from being thrown.
-      Errors `tryEval` will not catch are for example those created
-      by `abort` and type errors generated by builtins. Also note that
+      successful and `false` otherwise. Note that
       this doesn't evaluate *e* deeply, so `let e = { x = throw ""; };
       in (builtins.tryEval e).success` will be `true`. Using
       `builtins.deepSeq` one can get the expected result:
-- 
2.40.1

